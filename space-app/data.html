<!doctype html>
<html lang="en">
<head>
	<title>Skybox and Earth</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
      body{
        background-color: #000000;
        margin: 0;
        overflow: hidden;
      }
    </style>
</head>
<body>

<script src="three.js"></script>
<script src="OrbitControls.js"></script>
<script src="Detector.js"></script>
<script src="THREEx.WindowResize.js"></script>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

<script>
// standard global variables
var container, scene, camera, renderer, controls;

	// SCENE
	scene = new THREE.Scene();

	// CAMERA
	// view angle is actually the focus of view
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, aspect = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, aspect, NEAR, FAR);
	scene.add(camera);
	camera.position.set(200,150,400);
	camera.lookAt(scene.position);

	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );

	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.maxDistance = 5000;
	controls.minDistance = 2;

	// LIGHT
	var light = new THREE.SpotLight(0xffffff, 1, 0, 10, 2);
	scene.add(light);
	// Light Configurations
    light.position.set(-6, 5, 10);
	
	
	////////////
	// CUSTOM //
	////////////

	let planetProto = {
          sphere: function(size) {
            let sphere = new THREE.SphereGeometry(size, 32, 32);
            
            return sphere;
          },
          material: function(options) {
            let material = new THREE.MeshPhongMaterial();
            if (options) {
              for (var property in options) {
                material[property] = options[property];
              } 
            }
            
            return material;
          },
          glowMaterial: function(intensity, fade, color) {
            let glowMaterial = new THREE.ShaderMaterial({
              uniforms: { 
                'c': {
                  type: 'f',
                  value: intensity
                },
                'p': { 
                  type: 'f',
                  value: fade
                },
                glowColor: { 
                  type: 'c',
                  value: new THREE.Color(color)
                },
                viewVector: {
                  type: 'v3',
                  value: camera.position
                }
              },
              vertexShader: `
                uniform vec3 viewVector;
                uniform float c;
                uniform float p;
                varying float intensity;
                void main() {
                  vec3 vNormal = normalize( normalMatrix * normal );
                  vec3 vNormel = normalize( normalMatrix * viewVector );
                  intensity = pow( c - dot(vNormal, vNormel), p );
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`
              ,
              fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() 
                {
                  vec3 glow = glowColor * intensity;
                  gl_FragColor = vec4( glow, 1.0 );
                }`
              ,
              side: THREE.BackSide,
              blending: THREE.AdditiveBlending,
              transparent: true
            });
            
            return glowMaterial;
          },
          texture: function(material, property, uri) {
            let textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = true;
            textureLoader.load(
              uri,
              function(texture) {
                material[property] = texture;
                material.needsUpdate = true;
              }
            );
          }
        };

        let createPlanet = function(options) {
          // Create the planet's Surface
          let surfaceGeometry = planetProto.sphere(options.surface.size);
          let surfaceMaterial = planetProto.material(options.surface.material);
          let surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
          
          // Create the planet's Atmosphere
          let atmosphereGeometry = planetProto.sphere(options.surface.size + options.atmosphere.size);
          let atmosphereMaterialDefaults = {
            side: THREE.DoubleSide,
            transparent: true
          }
          let atmosphereMaterialOptions = Object.assign(atmosphereMaterialDefaults, options.atmosphere.material);
          let atmosphereMaterial = planetProto.material(atmosphereMaterialOptions);
          let atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
          
          // Create the planet's Atmospheric glow
          let atmosphericGlowGeometry = planetProto.sphere(options.surface.size + options.atmosphere.size + options.atmosphere.glow.size);
          let atmosphericGlowMaterial = planetProto.glowMaterial(options.atmosphere.glow.intensity, options.atmosphere.glow.fade, options.atmosphere.glow.color);
          let atmosphericGlow = new THREE.Mesh(atmosphericGlowGeometry, atmosphericGlowMaterial);
          
          // Nest the planet's Surface and Atmosphere into a planet object
          let planet = new THREE.Object3D();
          surface.name = 'surface';
          atmosphere.name = 'atmosphere';
          atmosphericGlow.name = 'atmosphericGlow';
          planet.add(surface);
          planet.add(atmosphere);
          planet.add(atmosphericGlow);

          // Load the Surface's textures
          for (let textureProperty in options.surface.textures) {
            planetProto.texture(
              surfaceMaterial,
              textureProperty,
              options.surface.textures[textureProperty]
            ); 
          }
          
          // Load the Atmosphere's texture
          for (let textureProperty in options.atmosphere.textures) {
            planetProto.texture(
              atmosphereMaterial,
              textureProperty,
              options.atmosphere.textures[textureProperty]
            );
          }
          
          return planet;
        };

        let earth = createPlanet({
          surface: {
            size: 0.5,
            material: {
              bumpScale: 0.05,
              specular: new THREE.Color('grey'),
              shininess: 10
            },
            textures: {
              map: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthmap1k.jpg',
              bumpMap: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthbump1k.jpg',
              specularMap: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthspec1k.jpg'
            }
          },
          atmosphere: {
            size: 0.003,
            material: {
              opacity: 0.8
            },
            textures: {
              map: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthcloudmap.jpg',
              alphaMap: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthcloudmaptrans.jpg'
            },
            glow: {
              size: 0.02,
              intensity: 0.7,
              fade: 7,
              color: 0x93cfef
            }
          },
        });
    camera.position.set(1, aspect, 0.1, 1500);
    camera.lookAt(earth.position);
    scene.add(earth);

    // Mesh Configurations
        earth.receiveShadow = true;
        earth.castShadow = true;
        earth.getObjectByName('surface').geometry.center();
	
	var imagePrefix = "../img/background-";
	var directions  = ["ft", "bk", "up", "dn", "rt", "lf"];
	var imageSuffix = ".png";
	var skyGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );	
	
	var materialArray = [];
	for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
			side: THREE.BackSide
		}));
	var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
	scene.add( skyBox );

	// Main render function
        let render = function() {
          earth.getObjectByName('surface').rotation.y += 1/32 * 0.3;
          earth.getObjectByName('atmosphere').rotation.y += 1/16 * 0.3;
          requestAnimationFrame(render);
          renderer.render(scene, camera);
        };

        render();
</script>

</body>
</html>